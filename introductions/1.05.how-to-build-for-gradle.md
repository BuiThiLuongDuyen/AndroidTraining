---
title: Android のビルドについて(Gradle)
---
この章では、Androidのアプリを作る上で知っておくべき事柄を解説します。

参考：[Application Fundamentals | Android Developers](http://developer.android.com/guide/components/fundamentals.html)

参考：[Context | Android Developers](http://developer.android.com/reference/android/content/Context.html)

参考：[Intents and IntentFilters | Android Developers](http://developer.android.com/guide/components/intents-filters.html)

参考：[Processes and Threads | Android Developers](http://developer.android.com/guide/components/processes-and-threads.html)

## 目次

- [Components](#components)
- [Context](#context)
	- [Contextとは？](#contextとは？)
	- [Contextの種類](#contextの種類)
- [Resource](#resource)
	- [アプリケーションリソース](#アプリケーションリソース)
	- [ストレージリソース](#ストレージリソース)
- [Messaging](#messaging)
	- [Intent](#intent)
- [Processes and Threads](#processes-and-threads)
	- [プロセス](#プロセス)
		- [優先順位](#優先順位)
	- [スレッド](#スレッド)
- [実習・課題](#実習・課題)

## Components
Android アプリを作る上で、最も重要かつ頻繁に利用するコンポーネントは以下の4つです。
<dl>
<dt>Activity</dt>
<dd>画面を構成するコンポーネントです。MVC の Controller に相当します。</dd>
<dt>Service</dt>
<dd>バックグラウンドで動作するコンポーネントですが、基本はメインスレッドで動作します。
IntentService と呼ばれる特殊な Service コンポーネントは、専用のワーカスレッドで動作します。 
</dd>
<dt>ContentProvider</dt>
<dd>アプリケーションが保有するデータへのアクセスの窓口となるインタフェースです。
多くはSQLiteデータベースへの窓口とするために用いられますが、この他にも、クラウド上のデータへのアクセスや、その他ストレージ上の永続化データへの窓口となることもできます。
ContentProviderというインタフェースを介することで、他のアプリからもデータソースへアクセスしたり、変更したりすることができるようになります。</dd>
<dt>BroadcastReceiver</dt>
<dd>アプリ全体や、端末全体に渡るメッセージ通知を受け取るコンポーネントです。
Router のような役割を担います。</dd>
</dl>

## Context

Android アプリを作る上で知っておくべきものの1つに、Context があります。
Context は、Android アプリを作る際、様々なところで登場します。 

### Contextとは？

**Android OS の環境やリソースへのアクセスの窓口** となるコンポーネントです。
データベースやファイル、アプリで利用する画像データなどへのアクセスの窓口となるほか、他のアプリとの連携や、アプリ情報へのアクセスの窓口ともなります。
また、 **Context はライフサイクルを持っています** 。 端末の様々な **状態遷移** の管理も、Context の仕事です。
Context にはいくつかの種類が存在します。アプリを作る際には、 **どの種類の Context かを意識する必要があります** 。

> Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc.

### Contextの種類

<dl>
<dt>Application</dt>
<dd>Context の一種で、Android アプリ全体を統括するものです。
アプリケーションが起動してから終了するまでのライフサイクルを管理します。 </dd>
<dt>Activity</dt>
<dd>Context の一種で、1つの画面を統括するものです。MVC モデルの、コントローラに相当する役割を担います。
1つの画面が構成され、バックグラウンドに移るか、終了するまでのライフサイクルを管理します。 </dd>
<dt>Service</dt>
<dd>Context の一種で、画面を持たず、バックグラウンドで動作します。
バックグラウンドで常に動き続ける常駐型の Service と、都度起動と終了をする Service の2種類があります。
Service が作られてから終了するまでのライフサイクルを管理します。</dd>
</dl>

## Resource

Androidアプリでは、様々な種類のリソースに触れることがあります。

### アプリケーションリソース

Android プロジェクトの res ディレクトリに格納する各種リソースです。

<dl>
<dt>String Resources</dt>
<dd>アプリ内で利用する文言などの文字列を、XML に分離して書き出します。文言フォーマットを定義することもできます。
Java のコードに埋め込むのではなく、XML に分離して書きだしておくことが推奨されています。
これにより、多言語化対応が容易になります。</dd>

<dt>Drawable Resources</dt>
<dd>アプリ内で利用するグラフィックリソースです。
png 等の画像ファイルの他、XML で簡単なグラフィックを書いたり、UI の状態（押された、選択された、フォーカスされた、通常）ごとのグラフィックの対応付けを書いたりしたものも Drawable Resources になります。
9パッチと呼ばれる特殊なフォーマットにも対応しているため、柔軟なUIパーツを作ることができます。</dd>

<dt>Color Resources</dt>
<dd>アプリ内で利用する、色のリソースです。
カラーコードに名前を振って、アプリ内で共有することができます。 
このリソースも、Drawable Resources 同様、XML 形式で、View の状態に応じた色の定義をすることができます。 </dd>

<dt>Menu Resources</dt>
<dd>メニューキーで呼ばれるメニューや、長押しで呼ばれるメニューを定義するのが Menu Resources です。
メニューに表示する文言やアイコンなどを定義することができます。</dd>

<dt>Style Resources</dt>
<dd>UIのスタイルを定義します。</dd>

<dt>Animation Resources</dt>
<dd>UI のアニメーションをXMLで定義するものです。
Tween アニメーション（移動、拡大縮小など）を扱います。</dd>
</dl>

### ストレージリソース

内蔵メモリに保存されるデータへのインタフェース群です。

<dl>
<dt>Database(Content Provider)</dt>
<dd>SQLite を用いたデータベースです。<br />
<br />
ContentProvider というインタフェースを用意することで、他のAndroidアプリ向けにモデルを提供出来るようになります。
OS 標準では、ギャラリーやカレンダーなどのデータベースへのインタフェースとして ContentProvider が利用されています。
通常、ContentProvider で提供されているリソースのアクセスは、ContentResolver オブジェクトを介して行います。<br />
<br />
Android のファイルシステムの中では、<pre>/data/data/(package name)/databases</pre>以下のディレクトリに、SQLite3 のデータベースファイルが指定した名前で格納されます。
</dd>

<dt>SharedPreferences</dt>
<dd>アプリ内で共有する設定ファイルのモデルです。<br />
<br />
中身は XML ファイルになっており、各種プリミティブ型と String 型、Set<String> 型のデータを格納することができます。<br />
SharedPreferences の XML ファイルへのアクセス権限を設定することができ、他のアプリからも見える形にすることも可能ですが、セキュリティホールの原因となるため、自分のアプリ以外からはアクセスできないように設定するべきです。<br />
<br />
Android のファイルシステムの中では、<pre>/data/data/(package name)/shared_prefs</pre>以下のディレクトリに、指定した名前で保存されます（一部端末で、<a href="http://alpha.mixi.co.jp/2013/11572/">保存場所が違う</a>ことによる不具合が報告されています）。</dd>

<dt>Internal Storage</dt>
<dd>
データベースファイルや XML ファイル以外に、直接内蔵メモリにファイルを保存するインタフェースも用意されています。<br />
<br />
デフォルトでは、アクセス権限は自分のアプリのみしか持っていませんが、SharedPreferences 同様他のアプリからもアクセスデキるようにすることができます（非推奨）。<br />
<br />
Android では、標準の API として、Internal Storage を使ったキャッシュの仕組みを公開しています。Internal Storage の容量が少なくなると、システムが自動的にキャッシュファイルを削除するようになりますが、自前でアプリが利用するキャッシュファイルの管理（総容量の管理、CRUD）をするべきです。
</dd>

<dt>External Storage</dt>
<dd>
外部ストレージとして、SD カードや、外部ストレージ扱いの内蔵メモリを扱うことができます。<br />
<br />
外部ストレージに配置するファイルにはアクセス権限の設定がありませんので、どのアプリからでも読み取ることが可能です。このため、秘匿すべきデータを外部ストレージに書き込むべきではありません。<br />
<br />
また、外部ストレージは取り外し可能な場合があるため、常にアクセス可能とは限りません。SD カードのようなメディアを取り外す以外に、ストレージ扱いで USB 接続中や電源を入れた直後も、SD カードがマウント状態とはならない為、External Storage にアクセスできなくなります。<br />
<br />
External Storage のデータは<pre>/sdcard/Android/data</pre>に格納されます。
</dd>
</dl>

## Messaging

アプリを作っていくと、ActivityやServiceなどのコンポーネントが複数作られていきます。

それらの **コンポーネントを疎に結びつける仕組み**として、Intentというメッセージングのフレームワークが用意されています。

### Intent

Intentとは、Androidにおけるコンポーネント同士を結びつけるメッセージングの仕組みで、
Intentオブジェクト自身は、実行してほしい処理を抽象的に記述するデータ構造を持つものです。

各々のコンポーネントは、渡されるIntentを元に処理を実行したり、渡ってくるべきIntentへの期待値を表明することができます。

Intentは、自分のアプリ内のコンポーネントだけでなく、他のアプリのコンポーネントを呼び出すことにも利用されます。

> An intent is an abstract description of an operation to be performed. It can be used with startActivity to launch an Activity, broadcastIntent to send it to any interested BroadcastReceiver components, and startService(Intent) or bindService(Intent, ServiceConnection, int) to communicate with a background Service.

> An Intent provides a facility for performing late runtime binding between the code in different applications. Its most significant use is in the launching of activities, where it can be thought of as the glue between activities. It is basically a passive data structure holding an abstract description of an action to be performed.

<dl>
<dt>明示的Intent</dt>
<dd>誰に結びつくIntentかを表明しているIntentです。</dd>

<dt>暗黙的Intent</dt>
<dd>誰に結びつくIntentかは直接表明せず、より抽象的に、期待する処理をしてくれるコンポーネントを呼び出すためのIntentです。
これにより、例えば、カメラを起動したいときに暗黙的Intentを利用することで、ユーザが好みのカメラアプリを選択できるようになったりします。 </dd>

<dt>IntentFilter</dt>
<dd>コンポーネント自身が、どのようなIntentを期待しているかを表明する仕組みです。
このフィルタを通過したコンポーネントが、期待通りのIntentを受け取れるものとみなされます。</dd>
</dl>

## Processes and Threads

Androidアプリは、アプリごとに割当てられた1つのLinuxプロセスの、1つのスレッド（メインスレッド）で動作します。
プロセスは、アプリの要求に応じて複数作られることもありますが、基本的には1プロセスで動作させることが推奨されています。

### プロセス

アプリが起動すると、Linuxプロセスが1つ割当てられます。
アプリの終了が即ちそのプロセスの終了となるとは限らない為、アプリ自体は終了していても、アプリに割当てられたプロセスは生きていることがあります。 
割当てられていたプロセスが生きている内に、再度アプリを起動した場合は、そのプロセスが使いまわされます。

プロセスには優先順位が存在し、必要な場合に優先順位の低いプロセスが、システムによってkillされます。
主に、他に優先順位の高いプロセスがより多くのメモリを要求したり、メモリが不足したりした場合に、優先順位に基いてシステムがどのプロセスをkillするか決定します。

#### 優先順位
より上位に位置づけられるプロセスほど優先順位が高く、プロセスをkillされにくくなります。

1. フォアグラウンドプロセス(Foreground Process)
2. 可視プロセス(Visible Process)
3. サービスプロセス(Service Process)
4. バックグラウンドプロセス(Background Process)
5. 空プロセス(Empty Process)

アプリ内で、複数のプロセスを持つこともできますが、あまり推奨されません。
どうしても必要な場合に、Activity、Service、Broadcast Receiver、Content Providerの4つのコンポーネントに対して、独自のプロセスで動くよう設定することができます。

### スレッド

アプリが起動すると、システムは、割当てられたプロセスの中で、1つのスレッド（メインスレッド）を立ち上げます。
メインスレッドでは、様々なイベントをハンドリングしたり、UIの操作を受け付けたりする必要が有るため、UIスレッドとも呼ばれます。

各々のコンポーネントに対して個別にスレッドを作るわけではないので、同じプロセス上のコンポーネントは全て、UIスレッド上でインスタンス化されます。
このため、キーが押された等のシステムのコールバックメソッドもUIスレッド上で呼ばれます。

もしネットワーク通信やデータベース操作など、時間を要する処理をメインスレッド上で実行すると、すべてのUIのイベントを受け付けることができなくなってしまい、
5秒以上この状態が続くと、ANR(Application Not Responding)と扱われて警告ダイアログが表示されます。

また、他のスレッドからUIを操作することも禁止されています。この操作を行った場合、例外が発生してアプリがクラッシュします。

## 実習・課題

以下の項目に取り組んでください。

1. (実習)Android SDK 内の、下記の 2 つのディレクトリにあるコマンドを列挙してください。
  * sdk/tools/  
 
emulator-arm  		jobb  			screenshot2  
android  		emulator-mips  		lib  			source.properties  
ant  			emulator-x86  		lint  			support  
apps  			emulator64-arm  	mksdcard  		templates  
ddms  			emulator64-mips  	monitor  		traceview  
draw9patch  		emulator64-x86  	monkeyrunner  		uiautomatorviewer  
emulator  		hierarchyviewer  	
  * sdk/platform-tools/  

dmtracedump		hprof-conv		systrace
adb			etc1tool		source.properties
api			fastboot		sqlite3


2. (実習)上記のディレクトリにパスを通し、下記のコマンドを実行してください。
  * adb devices
  * adb shell
3. (実習)`adb shell`コマンドを使って、Android 内のファイルシステムにアクセスし、下記の項目を確認してください。
  * `/data/data`以下のディレクトリで`ls`コマンドを打っても、拒否されること
  * `/sdcard/Android/data`以下のディレクトリの中身を自由に読むことができること
4. (課題)`adb`コマンドを使って、下記の項目を実行してください（課題のファイルに、実行したコマンドを記録しておいてください）。
  * 端末のSD カード領域に、ローカルにあるファイルを転送する
  * 端末のSD カード領域から、ローカルにファイルを転送する
  * 課題用サンプルプロジェクトの apk ファイルをコマンド経由で端末にインストールする
  * インストールしたアプリを、コマンド経由でアンインストールする
この章では Android のビルド、とりわけ、**Gradle** というビルドシステムを用いたビルドについて解説したいと思います。

記述内容は

- _Android Studio 0.4.3_
- _Gradle 1.10_

時点のものです。


## 目次
- [Gradle とは](#gradle-とは)
    - [必要環境](#必要環境)
    - [ビルドの構成要素](#ビルドの構成要素)
- [Gradle に触れてみよう](#gradle-に触れてみよう)
    - [Hello world! の前に環境構築](#hello-world-の前に環境構築)
    - [プロジェクト構成](#プロジェクト構成)
    - [改めて、Hello world!](#改めて、hello-world)
    - [実行](#実行)
    - [記法](#記法)
    - [gradlew](#gradlew)
- [Android Studio における Gradle](#android-studio-における-gradle)
    - [ビルドスクリプト](#ビルドスクリプト)
    - [Android Studio の Project Structure との関係](#android-studio-の-project-structure-との関係)
- [More infomation](#more-infomation)

***


## Gradle とは

[Gradle](http://www.gradle.org/) とは、Java（JVM）環境におけるビルドシステムのことで、オープンソースプロジェクトとして無償で公開されています。  
特長としては、ビルドの記述を XML のような構造ではなく、Groovy ライクな 独自の DSL を用い、スクリプトとして記述できる点です。  
用意されているAPIを利用することで、強力な記述が可能となります。



#### 必要環境
バージョン 1.5 以上の JVM を必要とします。




#### ビルドの構成要素
ビルドスクリプトを実際に触る前に、簡単にビルドの概念を説明します。  

**ビルドは１つ以上のプロジェクトで構成**され、  
その**プロジェクトは１つ以上のタスクで構成**されます。  
以下の様なケースを想像してもらえるとイメージが湧きやすいかと思います。  

>『アプリパッケージCを生成するために、A及びBのjarが必要で、  
>　そのA及びBのjarを作るためのモジュールがあり、  
>　それらを使って、アプリパッケージCを作るためのビルドを用意する』  

A, B , Cそれぞれにモジュールがありそのビルドをビルドスクリプトで記述します。  
また、タスクとはこれ以上分割できないような作業の単位を指します。


## Gradle に触れてみよう

#### Hello world! の前に環境構築
練習だけなので、簡単に確認できる環境を用意します。  
[前章のAndroid Studioの項目](https://github.com/mixi-inc/AndroidTraining/wiki/1.03.-Android%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90-\(-Android-Studio-\))で、既に Android Studio をインストール済みかと思います。  
こちらに、Gradle が同梱されていますので、こちらを利用します。

説明は割愛しますが、別途、[Gradle公式サイト](http://www.gradle.org/downloads)よりダウンロードして、実行環境を構築して頂いても問題ありません。



#### プロジェクト構成
Android Studio でProjectを作ると、以下の様なツリー構造となります。
ビルドスクリプトは `build.gradle` となります。  
2つありますが、_ProjectRoot_ のものを使います。

```
├── .idea/
├── app/
│   ├── build/
│   ├── src/
│   ├── .gitignore
│   ├── app.iml
│   ├── build.gradle
│   └── proguard-rules.txt
├── gradle/
├── .gitignore
├── build.gradle <-- このファイルを使用します
├── gradle.properties
├── gradlew
├── gradlew.bat
├── local.properties
├── MyApplication.iml
└── settings.gradle
```

#### 改めて、Hello world!
`build.gradle`を開き、既に記載されているものはそのままにしておき、

```
task hello {
    doLast {
        println 'Hello world!'
    }
}
```

と末尾に追記してください。

#### 実行

編集を終えましたら、Android Studio 同梱の Terminal から以下のコマンドを実行してみてください。  
`hello`というタスクを実行するコマンドとなります。  
（Terminal は左下のランチャ or Tools > Open Terminal より起動できます。馴染みのものでも構いません）


```
% ./gradlew -q hello
```
`（Mac OS X / Linux プラットフォームの場合。Windows の場合は、gradlew.batを使用してください）`  
>※ `-q` オプションは、Gradle のログメッセージを抑制し、引数で与えたタスクのみ、ログ出力を行います。  
>　今回は練習なので、解りやすいようにこのオプションを利用しています。  
>　（他のオプションは [http://gradle.monochromeroad.com/docs/userguide/gradle_command_line.html](http://gradle.monochromeroad.com/docs/userguide/gradle_command_line.html) を参照してください）  
>　  
>　また、`gradlew`に実行権限がない場合は、`chmod +x gradlew`として、権限を付与して実行してみてください。


```
Hello world!
```
と出力されたでしょうか。

また、ショートカットを用いて、以下の様に記述することも可能です。  

```
task hello << {
    println 'Hello world!'
}
```





#### 記法
記法の全てをここでは伝えませんが、基本的なものを紹介します。

###### 基本型
```
task hoge << {
    String fuga = 'fuga'
    int count = 9
    println 'hoge' + fuga + 'piyo'
	println count.toString()
}
```
```
% ./gradlew -q hoge                                                                                                
hogefugapiyo
9

```

###### 繰り返し
```
task count << {
    3.times {
        println $it
    }
}
```
```
% ./gradlew -q count                                                                                                
0
1
2
```

###### 依存関係の記述
```
task unlockDoor << {
    println "I unlock the door"
}
task enterMyRoom(dependsOn: unlockDoor) << {
    println "I'm home"
}
task relax(dependsOn: enterMyRoom) << {
    println "Relax..."
}
```

```
% ./gradlew -q relax                                                                                                
I unlock the door
I'm home
Relax...

% ./gradlew -q enterMyRoom                                                                                          
I unlock the door
I'm home
```

依存関係のあるタスクが先に実行されていることがわかるかと思います。   

それでは、順番を並び替えた以下を実行してください。

```
task enterMyRoom(dependsOn: unlockDoor) << {
    println "I'm home"
}
task unlockDoor << {
    println "I unlock the door"
}
```
```
% ./gradlew -q enterMyRoom
-> ERROR!
```

エラーが起こって正常に実行できないようになったかと思います。
これは、未定義な `unlockDoor` を呼びだそうとする事により、起こるエラーです。

以下の様に、呼び出しを文字列にしてあげるだけで、遅延評価されるようになり、問題は起こらなくなります。

```
task enterMyRoom(dependsOn: 'unlockDoor') << {
    println "I'm home"
}
task unlockDoor << {
    println "I unlock the door"
}
```
```
% ./gradlew -q enterMyRoom
I unlock the door
I'm home
```

また、task定義とは別に依存関係を記述することも可能です。

```
task unlockDoor << {
    println "I unlock the door"
}
task enterMyRoom << {
    println "I'm home"
}
task relax << {
    println "Relax..."
}

unlockDoor.dependsOn enterMyRoom
relax.dependsOn unlockDoor, enterMyRoom
```

###### taskの前後に処理を差し込む
```
task sample << {
	println 'hoge'
}
sample.doFirst {
	println 'hello!'
}
sample.doLast {
	println 'fuga'
}
sample << {
	println 'piyo'
}
```
```
%  ./gradlew -q sample                                                                                                
hello! 
hoge
fuga
piyo
```

`doFirst`, `doLast`（`<<`） を用いることで、タスクの前後に処理を追加することが可能です。  
複数の処理を同じ箇所に追加した場合は、定義された順番に実行されます。  
また、定義済み task は、上記の様にドットアクセスでタスクを記述できます。  





#### gradlew
上で`gradlew`（あるいは`gradlew.bat`）を用いてサンプルコードを実行していましたが、`gradlew`とはGradleラッパーといい、Gradleのビルド実行において推奨されている方法です。  
`gradlew`の実体はシェルスクリプトです。  
指定のバージョンのGradleをダウンロードし、それを用いてビルドを実行を行います。  
なので、`gradle`ではなく、`gradlew`を使うようにしておけば、環境に依存することがありません。

上記の観点より、`gradlew`をリポジトリに含めるようにしておいてください。  
そうすることで、CIや公開リポジトリなりで配布した際にもバージョン依存で悩む必要がなくなるはずです。

なお、`gradlew`には実行権限が必要なので、無ければ設定してください。




## Android Studio における Gradle

Android Studio のパッケージには Gradle が同梱しておりますので、
インストールしてすぐ利用することが可能です。

#### ビルドスクリプト
新規にプロジェクトを作成すると、以下の２つの `build.gradle` があると思います。

- Project直下の `build.gradle`
- app内の `build.gradle`

それぞれについて簡単に説明したいと思います。

###### Project直下の `build.gradle`

```
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:0.8.+'
    }
}

allprojects {
    repositories {
        mavenCentral()
    }
}
```

`buildscript` / `allprojects` の `repositories` は、外部からインポートする jar のリポジトリを指定します。  
デフォルトで `mavenCentral()` が指定されています。  
これで事が足りるとは思いますが、明示的に他のリポジトリも参照したい場合は以下のように記載します。  

```
buildscript {
    repositories {
        mavenCentral()
        maven {
        	url "{TARGET_REPOSITORY_URL}"
        }
    }
    ...
```

`dependencies`は依存関係を記述します。  
**外部のライブラリを読み込みたい場合はここに記述します。**  
すると、自動的にプロジェクトの`External Libraries`に読み込まれます。

デフォルトの様に`mavenCentral()` にあるものであれば、パスのみで記述できます。  
また、リポジトリが無い jar を読み込みたい場合は、以下の様にします。  
lib 以下の jar ファイルを読み込む設定です。

```
    dependencies {
        compile fileTree(dir:'libs', include: '*.jar')
    }
```


###### app内の `build.gradle`

```
apply plugin: 'android'

android {
    compileSdkVersion 19
    buildToolsVersion "19.0.1"

    defaultConfig {
        minSdkVersion 7
        targetSdkVersion 19
        versionCode 1
        versionName "1.0"
    }
    buildTypes {
        release {
            runProguard false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
        }
    }
}

dependencies {
    compile 'com.android.support:appcompat-v7:+'
}
```

`apply plugin: 'android'`はAndroidのPluginを使う上での宣言です。

`android`はビルドの情報を記載します。  
`defaultConfig`はデフォルトの設定を記載し、  
`buildTypes`はビルド毎の設定を記載します。



#### Android Studio の Project Structure との関係

`setting.gradle`というファイルを確認します。

```
include ':app'
```

と書かれているものが`Project Structure` > `Project Settings` > `Modules`に表示されます。  
上記の例だと、`app`モジュールの設定が表示されます。

しかしながら、一部表示されないものがあったり、メリットは少ないので、`build.gradle`を編集することをおすすめします。





## More infomation
Gradleの触りの部分を紹介しましたが、より理解を深めたい方は以下サイトを参照ください。

- [Gradle Documentation](http://www.gradle.org/documentation)
    - 邦訳：[Gradle 日本語ドキュメント](http://gradle.monochromeroad.com/docs/)
- [Gradle Build Language Reference](http://www.gradle.org/docs/current/dsl/index.html)
    - 邦訳：[Gradleビルド言語リファレンス](http://gradle.monochromeroad.com/docs/dsl/index.html)
- [Gradle Plugin User Guide](http://tools.android.com/tech-docs/new-build-system/user-guide)
